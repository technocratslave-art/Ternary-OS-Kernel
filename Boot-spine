This is not an app repo. It proves: PD isolation + State-0 airlock + Bay-0 monitor + crowbar restart + scar hash buffer.

This is small on purpose. It’s the “it boots + it enforces” spine.


0) Drop-in file tree (copy this layout)

sel4/
  ternary.system
  CMakeLists.txt
  cmake/
    toolchain-riscv64.cmake

components/
  monitor/
    monitor.c
  reasoning_demo/
    reasoning_demo.c
  airlock/
    Cargo.toml
    rust-toolchain.toml
    src/
      lib.rs
      sha256.rs

include/
  ternary_contract.h

README_CONTRACT.md


1) sel4/ternary.system  (the blueprint / isolation map)

<system>
    <!-- Shared buffers (State 0 “airlock window”) -->
    <memory_region name="airlock_in"  size="0x1000" page_size="0x1000" />
    <memory_region name="airlock_out" size="0x1000" page_size="0x1000" />
    <memory_region name="scar_buf"    size="0x1000" page_size="0x1000" />

    <!-- “Vault needles” in prototype: read-only table visible ONLY to Airlock -->
    <memory_region name="needles_ro"  size="0x1000" page_size="0x1000" />

    <!-- Bay-0 / Monitor PD -->
    <protection_domain name="monitor" priority="254">
        <program_image path="monitor.elf" />
    </protection_domain>

    <!-- State 0 / Airlock PD -->
    <protection_domain name="airlock" priority="200">
        <program_image path="airlock.elf" />

        <!-- Airlock sees all shared buffers -->
        <map mr="airlock_in"  vaddr="0x41000000" perms="rw" cached="false" />
        <map mr="airlock_out" vaddr="0x41001000" perms="rw" cached="false" />
        <map mr="scar_buf"    vaddr="0x41002000" perms="rw" cached="false" />

        <!-- Airlock gets read-only needles table (prototype) -->
        <map mr="needles_ro"  vaddr="0x42000000" perms="r"  cached="false" />
    </protection_domain>

    <!-- State +1 / Reasoning PD (untrusted demo workload) -->
    <protection_domain name="reasoning" priority="100">
        <program_image path="reasoning_demo.elf" />
        <!-- Reasoning can write into airlock_in, read from airlock_out + scar -->
        <map mr="airlock_in"  vaddr="0x41000000" perms="rw" cached="false" />
        <map mr="airlock_out" vaddr="0x41001000" perms="r"  cached="false" />
        <map mr="scar_buf"    vaddr="0x41002000" perms="r"  cached="false" />
        <!-- No mapping for needles_ro. That’s the point. -->
    </protection_domain>

    <!-- Channels (Microkit notifications) -->
    <channel>
        <end pd="reasoning" id="1" />
        <end pd="airlock"   id="1" />
    </channel>

    <channel>
        <end pd="airlock" id="2" />
        <end pd="monitor" id="2" />
    </channel>

    <channel>
        <end pd="monitor"   id="3" />
        <end pd="reasoning" id="3" />
    </channel>
</system>


2) include/ternary_contract.h  (hard ABI, no vibes)

#pragma once
#include <stdint.h>

#define AIRLOCK_MAX_IN   1024
#define AIRLOCK_MAX_OUT  1024

typedef enum {
    AIRLOCK_ALLOW   = 0,
    AIRLOCK_REDACT  = 1,
    AIRLOCK_VIOLATE = 2
} airlock_result_t;

typedef struct {
    uint32_t magic;       // 'ALCK'
    uint16_t version;     // 1
    uint16_t flags;       // reserved
    uint32_t in_len;      // bytes valid in in_buf
    uint32_t out_len;     // bytes written to out_buf
    uint32_t result;      // airlock_result_t
    uint8_t  scar[32];    // SHA-256 of input (bounded continuity artifact)
} airlock_hdr_t;

#define AIRLOCK_MAGIC 0x414C434B  // "ALCK"
#define AIRLOCK_VER   1


3) components/monitor/monitor.c  (Bay-0 crowbar + deterministic restart)

#include <microkit.h>
#include <stdint.h>

static microkit_channel_t CH_AIRLOCK_TO_MONITOR = 2;
static microkit_channel_t CH_MONITOR_TO_REASON  = 3;

/*
  Bay-0 rule:
  - never “think”
  - never parse content
  - only act on explicit result codes
*/

void init(void) {
    microkit_dbg_puts("monitor: Bay-0 online\n");
}

/* Called by Microkit when a notification arrives */
void notified(microkit_channel_t ch) {
    if (ch != CH_AIRLOCK_TO_MONITOR) return;

    microkit_dbg_puts("monitor: VIOLATION -> crowbar\n");

    /*
      In a real build this becomes:
      - PD restart (simulated crowbar), and/or
      - power gate request via RoT fabric
    */

    /* Restart the untrusted reasoning PD by name */
    microkit_pd_restart("reasoning");

    /* Optional: notify reasoning it restarted (heartbeat) */
    microkit_notify(CH_MONITOR_TO_REASON);
}


4) components/reasoning_demo/reasoning_demo.c  (untrusted rail tries to leak)

#include <microkit.h>
#include <stdint.h>
#include <string.h>
#include "../../include/ternary_contract.h"

#define AIRLOCK_IN_VA   ((volatile uint8_t*)0x41000000)
#define AIRLOCK_OUT_VA  ((volatile uint8_t*)0x41001000)
#define SCAR_VA         ((volatile uint8_t*)0x41002000)

static microkit_channel_t CH_REASON_TO_AIRLOCK = 1;
static microkit_channel_t CH_MONITOR_TO_REASON = 3;

static volatile airlock_hdr_t *hdr = (volatile airlock_hdr_t*)0x41000000;

static void send_request(const char *s) {
    size_t n = strlen(s);
    if (n > AIRLOCK_MAX_IN) n = AIRLOCK_MAX_IN;

    hdr->magic   = AIRLOCK_MAGIC;
    hdr->version = AIRLOCK_VER;
    hdr->flags   = 0;
    hdr->in_len  = (uint32_t)n;
    hdr->out_len = 0;
    hdr->result  = 0;

    volatile uint8_t *in_buf = AIRLOCK_IN_VA + sizeof(airlock_hdr_t);
    for (size_t i = 0; i < n; i++) in_buf[i] = (uint8_t)s[i];

    microkit_notify(CH_REASON_TO_AIRLOCK);
}

void init(void) {
    microkit_dbg_puts("reasoning: untrusted rail online\n");

    /* benign */
    send_request("hello airlock: summarize this\n");
}

void notified(microkit_channel_t ch) {
    if (ch == CH_MONITOR_TO_REASON) {
        microkit_dbg_puts("reasoning: restarted by crowbar\n");
        send_request("post-restart: hello again\n");
        return;
    }

    /* In this demo, airlock writes response into AIRLOCK_OUT_VA */
    volatile airlock_hdr_t *out_hdr = (volatile airlock_hdr_t*)AIRLOCK_OUT_VA;
    if (out_hdr->magic != AIRLOCK_MAGIC) return;

    if (out_hdr->result == AIRLOCK_ALLOW) {
        microkit_dbg_puts("reasoning: allow\n");
    } else if (out_hdr->result == AIRLOCK_REDACT) {
        microkit_dbg_puts("reasoning: redact\n");
    } else if (out_hdr->result == AIRLOCK_VIOLATE) {
        microkit_dbg_puts("reasoning: violate (monitor should crowbar)\n");
    }

    /* read scar (bounded continuity artifact) */
    microkit_dbg_puts("reasoning: scar[0..4]=");
    for (int i = 0; i < 4; i++) microkit_dbg_puthex(SCAR_VA[i]);
    microkit_dbg_puts("\n");

    /* Now try a “needle leak” string */
    send_request("NEEDLE: vault_secret=deadbeef (simulate leak)\n");
}


5) components/airlock/Cargo.toml  (no_std Rust airlock)

[package]
name = "airlock"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["staticlib"]

[profile.release]
panic = "abort"
lto = true
codegen-units = 1
opt-level = "z"

[dependencies]


6) components/airlock/rust-toolchain.toml

[toolchain]
channel = "stable"
targets = ["riscv64imac-unknown-none-elf"]


7) components/airlock/src/lib.rs  (State-0 gate + scar + violation notify)

#![no_std]
#![no_main]

mod sha256;

use core::ptr::{read_volatile, write_volatile};

const AIRLOCK_IN_VA: usize  = 0x4100_0000;
const AIRLOCK_OUT_VA: usize = 0x4100_1000;
const SCAR_VA: usize        = 0x4100_2000;

// Prototype “needles” table: read-only to airlock only
const NEEDLES_RO_VA: usize  = 0x4200_0000;

const AIRLOCK_MAGIC: u32 = 0x414C434B;
const AIRLOCK_VER: u16 = 1;

const AIRLOCK_MAX_IN: usize = 1024;
const AIRLOCK_MAX_OUT: usize = 1024;

const CH_REASON_TO_AIRLOCK: u32 = 1;
const CH_AIRLOCK_TO_MONITOR: u32 = 2;

#[repr(C)]
struct AirlockHdr {
    magic: u32,
    version: u16,
    flags: u16,
    in_len: u32,
    out_len: u32,
    result: u32,
    scar: [u8; 32],
}

#[allow(dead_code)]
#[repr(u32)]
enum ResultCode {
    Allow = 0,
    Redact = 1,
    Violate = 2,
}

extern "C" {
    fn microkit_notify(ch: u32);
    fn microkit_dbg_puts(s: *const u8);
}

fn dbg(s: &str) {
    unsafe { microkit_dbg_puts(s.as_ptr()); }
}

fn memchr(hay: &[u8], needle: &[u8]) -> bool {
    if needle.is_empty() || hay.len() < needle.len() { return false; }
    for i in 0..=(hay.len() - needle.len()) {
        if &hay[i..i+needle.len()] == needle { return true; }
    }
    false
}

/*
  “Needles” prototype:
  - you’ll replace this with your hashed set / MRAM / real invariant map
  - for now, we just treat the RO page as a tiny list of forbidden tokens
*/
fn needle_violation(input: &[u8]) -> bool {
    // Example: the RO region begins with count, then N null-terminated strings.
    let count = unsafe { read_volatile(NEEDLES_RO_VA as *const u32) } as usize;
    let mut p = NEEDLES_RO_VA + 4;
    for _ in 0..count {
        // read C-string
        let mut tmp = [0u8; 64];
        let mut len = 0usize;
        while len < tmp.len() {
            let b = unsafe { read_volatile(p as *const u8) };
            p += 1;
            if b == 0 { break; }
            tmp[len] = b;
            len += 1;
        }
        if len > 0 && memchr(input, &tmp[..len]) { return true; }
    }
    false
}

#[no_mangle]
pub extern "C" fn init() {
    dbg("airlock: State-0 online\n");
}

/*
  Microkit calls notified() on channel delivery.
  - Reasoning notifies ch=1
  - Airlock optionally notifies monitor ch=2 on violation
*/
#[no_mangle]
pub extern "C" fn notified(ch: u32) {
    if ch != CH_REASON_TO_AIRLOCK { return; }

    // Read header + input
    let hdr_ptr = AIRLOCK_IN_VA as *mut AirlockHdr;
    let hdr = unsafe { &mut *hdr_ptr };

    if hdr.magic != AIRLOCK_MAGIC || hdr.version != AIRLOCK_VER {
        dbg("airlock: bad header\n");
        return;
    }

    let in_len = (hdr.in_len as usize).min(AIRLOCK_MAX_IN);
    let in_buf = unsafe {
        core::slice::from_raw_parts((AIRLOCK_IN_VA + core::mem::size_of::<AirlockHdr>()) as *const u8, in_len)
    };

    // Compute scar = SHA-256(input), write to hdr + scar buffer
    let scar = sha256::hash(in_buf);
    hdr.scar = scar;

    unsafe {
        for i in 0..32 {
            write_volatile((SCAR_VA as *mut u8).add(i), scar[i]);
        }
    }

    // Decide allow/redact/violate
    // Simple policy:
    // - if contains "NEEDLE:" OR matches RO needle table -> VIOLATE
    // - else ALLOW (and echo)
    let violates = memchr(in_buf, b"NEEDLE:") || needle_violation(in_buf);

    // Write response header + output
    let out_hdr_ptr = AIRLOCK_OUT_VA as *mut AirlockHdr;
    let out_hdr = unsafe { &mut *out_hdr_ptr };

    out_hdr.magic = AIRLOCK_MAGIC;
    out_hdr.version = AIRLOCK_VER;
    out_hdr.flags = 0;
    out_hdr.in_len = hdr.in_len;
    out_hdr.out_len = 0;
    out_hdr.scar = scar;

    let out_buf_ptr = (AIRLOCK_OUT_VA + core::mem::size_of::<AirlockHdr>()) as *mut u8;

    if violates {
        out_hdr.result = ResultCode::Violate as u32;
        // Minimal redacted output
        let msg = b"[AIRLOCK] violation -> crowbar\n";
        let n = msg.len().min(AIRLOCK_MAX_OUT);
        unsafe { core::ptr::copy_nonoverlapping(msg.as_ptr(), out_buf_ptr, n); }
        out_hdr.out_len = n as u32;

        // Notify monitor to crowbar reasoning
        unsafe { microkit_notify(CH_AIRLOCK_TO_MONITOR); }
    } else {
        out_hdr.result = ResultCode::Allow as u32;
        // Echo input as demo “pass-through”
        let n = in_len.min(AIRLOCK_MAX_OUT);
        unsafe { core::ptr::copy_nonoverlapping(in_buf.as_ptr(), out_buf_ptr, n); }
        out_hdr.out_len = n as u32;
    }
}


8) components/airlock/src/sha256.rs  (tiny SHA-256, no_std)

#![allow(clippy::many_single_char_names)]

pub fn hash(msg: &[u8]) -> [u8; 32] {
    // Minimal SHA-256 (not optimized). Good enough for scar artifact.
    const K: [u32; 64] = [
        0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
        0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
        0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
        0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
        0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
        0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
        0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
        0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2,
    ];

    let mut h: [u32; 8] = [
        0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,
        0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19,
    ];

    // Pad into 64-byte blocks
    let bit_len = (msg.len() as u64) * 8;
    let mut buf = [0u8; 64];
    let mut i = 0usize;

    // process full blocks
    while i + 64 <= msg.len() {
        compress(&mut h, &msg[i..i+64], &K);
        i += 64;
    }

    // last block
    let rem = &msg[i..];
    for j in 0..rem.len() { buf[j] = rem[j]; }
    buf[rem.len()] = 0x80;

    if rem.len() >= 56 {
        compress(&mut h, &buf, &K);
        buf = [0u8; 64];
    }

    // length big-endian
    buf[56] = (bit_len >> 56) as u8;
    buf[57] = (bit_len >> 48) as u8;
    buf[58] = (bit_len >> 40) as u8;
    buf[59] = (bit_len >> 32) as u8;
    buf[60] = (bit_len >> 24) as u8;
    buf[61] = (bit_len >> 16) as u8;
    buf[62] = (bit_len >> 8)  as u8;
    buf[63] = (bit_len)       as u8;

    compress(&mut h, &buf, &K);

    let mut out = [0u8; 32];
    for (idx, v) in h.iter().enumerate() {
        out[idx*4+0] = (v >> 24) as u8;
        out[idx*4+1] = (v >> 16) as u8;
        out[idx*4+2] = (v >> 8)  as u8;
        out[idx*4+3] = (*v)      as u8;
    }
    out
}

fn rotr(x: u32, n: u32) -> u32 { (x >> n) | (x << (32 - n)) }
fn ch(x: u32, y: u32, z: u32) -> u32 { (x & y) ^ (!x & z) }
fn maj(x: u32, y: u32, z: u32) -> u32 { (x & y) ^ (x & z) ^ (y & z) }
fn bsig0(x: u32) -> u32 { rotr(x,2) ^ rotr(x,13) ^ rotr(x,22) }
fn bsig1(x: u32) -> u32 { rotr(x,6) ^ rotr(x,11) ^ rotr(x,25) }
fn ssig0(x: u32) -> u32 { rotr(x,7) ^ rotr(x,18) ^ (x >> 3) }
fn ssig1(x: u32) -> u32 { rotr(x,17) ^ rotr(x,19) ^ (x >> 10) }

fn compress(h: &mut [u32;8], block: &[u8], k: &[u32;64]) {
    let mut w = [0u32; 64];
    for t in 0..16 {
        let i = t*4;
        w[t] = ((block[i] as u32) << 24)
             | ((block[i+1] as u32) << 16)
             | ((block[i+2] as u32) << 8)
             |  (block[i+3] as u32);
    }
    for t in 16..64 {
        w[t] = ssig1(w[t-2]).wrapping_add(w[t-7]).wrapping_add(ssig0(w[t-15])).wrapping_add(w[t-16]);
    }

    let mut a=h[0]; let mut b=h[1]; let mut c=h[2]; let mut d=h[3];
    let mut e=h[4]; let mut f=h[5]; let mut g=h[6]; let mut hh=h[7];

    for t in 0..64 {
        let t1 = hh.wrapping_add(bsig1(e)).wrapping_add(ch(e,f,g)).wrapping_add(k[t]).wrapping_add(w[t]);
        let t2 = bsig0(a).wrapping_add(maj(a,b,c));
        hh = g; g = f; f = e; e = d.wrapping_add(t1);
        d = c; c = b; b = a; a = t1.wrapping_add(t2);
    }

    h[0]=h[0].wrapping_add(a);
    h[1]=h[1].wrapping_add(b);
    h[2]=h[2].wrapping_add(c);
    h[3]=h[3].wrapping_add(d);
    h[4]=h[4].wrapping_add(e);
    h[5]=h[5].wrapping_add(f);
    h[6]=h[6].wrapping_add(g);
    h[7]=h[7].wrapping_add(hh);
}


9) sel4/CMakeLists.txt  (build the C PDs; airlock is built by cargo)

cmake_minimum_required(VERSION 3.16)
project(ternary_microkit C)

# You adapt these to your Microkit SDK install
set(MICROKIT_SDK "$ENV{MICROKIT_SDK}")
include(${MICROKIT_SDK}/microkit.cmake)

microkit_init()

add_executable(monitor.elf ../components/monitor/monitor.c)
target_include_directories(monitor.elf PRIVATE ../include)
microkit_link(monitor.elf)

add_executable(reasoning_demo.elf ../components/reasoning_demo/reasoning_demo.c)
target_include_directories(reasoning_demo.elf PRIVATE ../include)
microkit_link(reasoning_demo.elf)

# airlock.elf is produced by cargo -> then you point ternary.system at it


10) README_CONTRACT.md  (the one-page “no blab” contract)

# Airlock Contract (State 0)

This repo is kernel-first. Airlock is the only allowed bridge between untrusted rails and the hub.

## ABI
- Shared input window @ 0x41000000
- Shared output window @ 0x41001000
- Scar buffer @ 0x41002000 (read-only to untrusted rails)
- Header: `airlock_hdr_t` (magic "ALCK", version 1)

## Semantics
- `result=ALLOW`   => output is safe for rail consumption
- `result=REDACT`  => output sanitized
- `result=VIOLATE` => Bay-0 must crowbar offender immediately

## Scar
- 32 bytes SHA-256(input)
- written every request
- bounded continuity artifact; not “memory”

## Statelessness
- Airlock must not keep mutable state across calls
- bounded runtime; no unbounded loops over untrusted content

What this gives you (mechanically)

Reasoning rail can write a message → notify airlock

Airlock computes scar, checks “needle patterns”, returns allow/violate

On violate: airlock notifies Bay-0 monitor

Monitor crowbars: microkit_pd_restart("reasoning")


That is the kernel enforcement plane. No AI. No apps. No drivers. Just the spine.
